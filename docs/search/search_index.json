{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to WebGear \u00b6 WebGear is a Haskell library to build composable, extensible, and type-Safe HTTP APIs. Hello WebGear \u00b6 Here is a fully functional WebGear application. If you access http://localhost:3000/hello/Legolas , you'd get a 200 OK response with body: Hello, Legolas . {-# LANGUAGE DataKinds, QuasiQuotes, TypeApplications #-} import Network.HTTP.Types ( StdMethod ( GET )) import Network.Wai.Handler.Warp import WebGear routes :: Handler '[] String routes = [ route | GET / hello / name :String | ] $ Kleisli $ \\ request -> do let name = get ( Proxy @ ( PathVar \"name\" String )) request return $ ok200 ( \"Hello, \" ++ name ) main :: IO () main = run 3000 ( toApplication routes ) Developer Friendly \u00b6 WebGear is built on a small set of simple concepts which makes it approachable. You don't need to be a Haskell Guru to build APIs with WebGear. Friendly error messages will guide you when you make mistakes. Composability \u00b6 APIs are built by composing functions to form handlers and middlewares. Build complex APIs from smaller simpler parts! putUser = method @ PUT $ requestContentTypeHeader @ \"application/json\" $ jsonRequestBody @ User $ jsonResponseBody @ User $ putUserHandler Extensibility \u00b6 Every component of WebGear can be replaced with alternative implementations should you wish so. Your custom middlewares are as first-class as the ones provided by WebGear. APIs run with the framework of your choice. WebGear can work with monad transformers or algebraic effect systems that you want to use.","title":"Home"},{"location":"#welcome-to-webgear","text":"WebGear is a Haskell library to build composable, extensible, and type-Safe HTTP APIs.","title":"Welcome to WebGear"},{"location":"#hello-webgear","text":"Here is a fully functional WebGear application. If you access http://localhost:3000/hello/Legolas , you'd get a 200 OK response with body: Hello, Legolas . {-# LANGUAGE DataKinds, QuasiQuotes, TypeApplications #-} import Network.HTTP.Types ( StdMethod ( GET )) import Network.Wai.Handler.Warp import WebGear routes :: Handler '[] String routes = [ route | GET / hello / name :String | ] $ Kleisli $ \\ request -> do let name = get ( Proxy @ ( PathVar \"name\" String )) request return $ ok200 ( \"Hello, \" ++ name ) main :: IO () main = run 3000 ( toApplication routes )","title":"Hello WebGear"},{"location":"#developer-friendly","text":"WebGear is built on a small set of simple concepts which makes it approachable. You don't need to be a Haskell Guru to build APIs with WebGear. Friendly error messages will guide you when you make mistakes.","title":"Developer Friendly"},{"location":"#composability","text":"APIs are built by composing functions to form handlers and middlewares. Build complex APIs from smaller simpler parts! putUser = method @ PUT $ requestContentTypeHeader @ \"application/json\" $ jsonRequestBody @ User $ jsonResponseBody @ User $ putUserHandler","title":"Composability"},{"location":"#extensibility","text":"Every component of WebGear can be replaced with alternative implementations should you wish so. Your custom middlewares are as first-class as the ones provided by WebGear. APIs run with the framework of your choice. WebGear can work with monad transformers or algebraic effect systems that you want to use.","title":"Extensibility"},{"location":"show-me-the-code/","text":"Show me the code! \u00b6 This is a whirlwind tour of WebGear. If you want to learn more, go to the user guide . Building Request Handlers \u00b6 A request handler is just a function that takes a request value and produces a response value in a monadic context. This is where the business logic of your application lives. -- The 'Has (JSONRequestBody Widget) r' constrait indicates that this handler -- can only be called if the request body is a valid JSON that can be parsed -- to a Widget value. putWidget :: Has ( JSONRequestBody Widget ) r => Handler r Widget putWidget = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req saveToDB widget return ( ok200 widget ) The Handler req Widget type in the example above is equivalent to the function type Monad m => Linked req Request -> m ( Response Widget ) in principle. These type of functions are also known as Kleisli arrows; hence the use of Kleisli in the handler. Accessing Request Traits \u00b6 Traits are attributes associated with the request. Header values, query parameters, path components, request body are all examples of traits. The trait values are accessed using the get function. someHandler :: Have [ PathVar \"widgetId\" UUID , JSONRequestBody Widget , QueryParam \"limit\" Integer ] r => Handler r a someHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget wid = get ( Proxy @ ( PathVar \"widgetId\" UUID )) req -- wid :: UUID limit = get ( Proxy @ ( QueryParam \"limit\" Integer )) req -- limit :: Integer ... return noContent204 Sending Responses \u00b6 The response value returned contains the HTTP status code, response headers, and optionally a body. The body can be any type that can be converted to a lazy ByteString using the ToByteString type class. createWidget = Kleisli $ \\ req -> do ... return ( created201 widget ) In addition to functions such as ok200 and created201 , there is a generic respond function that accepts an HTTP status code, response headers and the body to generate a response. Routing without TemplateHaskell \u00b6 You can use regular functions instead of TemplateHaskell QuasiQuoters for routing if you prefer that. -- matches GET /hello/name:String helloRoute :: Handler '[] String helloRoute = method @ GET $ path @ \"hello\" $ pathVar @ \"name\" @ String $ Kleisli $ \\ req -> do let name = get ( Proxy @ ( PathVar \"name\" String )) req return $ ok200 $ \"Hello, \" ++ name Composable routes \u00b6 Compose routes with <|> . During request routing, each of these routes will be tried sequentially and the first matching handler will be called. allRoutes :: Handler r a allRoutes = createWidget <|> getWidget <|> updateWidget <|> deleteWidget Since handlers are functions, you can refactor and compose them as you wish. The below example shows an application with v1 and v2 path prefixes. allRoutes :: Handler r a allRoutes = v1Routes <|> v2Routes -- matches any path starting with /v1 v1Routes :: Handler r a v1Routes = [ match | / v1 ] $ v1CreateWidget <|> v1GetWidget <|> v1UpdateWidget <|> v1DeleteWidget -- matches any path starting with /v2 v2Routes :: Handler r a v2Routes = [ match | / v2 ] $ v2CreateWidget <|> v2GetWidget <|> v2UpdateWidget <|> v2DeleteWidget Middlewares \u00b6 Middlewares are handlers that wrap another handler. They usually modify or enhance the behaviour of the inner handler. For example, the queryParam middleware ensures that the inner handler is invoked only when the request contains a query parameter named limit . searchWidget :: Handler '[] a searchWidget = queryParam @ \"limit\" @ Int searchHandler searchHandler :: Has ( QueryParam \"limit\" Int ) r => Handler r a searchHandler = ... Typically, you will compose many middlewares to form a route handler. The user guide explains how you can build your own middlewares. First-class JSON support \u00b6 Use JSON input and output in your handlers without any boilerplate. WebGear uses the aeson library to handle JSON values. The request body can be read as a JSON value using jsonRequestBody middleware. The response can be converted to a lazy ByteString using the jsonResponseBody middleware. updateWidget :: Handler '[] ByteString updateWidget = jsonRequestBody @ Widget $ jsonResponseBody @ Widget $ updateWidgetHandler updateWidgetHandler :: Has ( JSONRequestBody Widget ) r => Handler r Widget updateWidgetHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget ... return $ ok200 widget","title":"Show me the code!"},{"location":"show-me-the-code/#show-me-the-code","text":"This is a whirlwind tour of WebGear. If you want to learn more, go to the user guide .","title":"Show me the code!"},{"location":"show-me-the-code/#building-request-handlers","text":"A request handler is just a function that takes a request value and produces a response value in a monadic context. This is where the business logic of your application lives. -- The 'Has (JSONRequestBody Widget) r' constrait indicates that this handler -- can only be called if the request body is a valid JSON that can be parsed -- to a Widget value. putWidget :: Has ( JSONRequestBody Widget ) r => Handler r Widget putWidget = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req saveToDB widget return ( ok200 widget ) The Handler req Widget type in the example above is equivalent to the function type Monad m => Linked req Request -> m ( Response Widget ) in principle. These type of functions are also known as Kleisli arrows; hence the use of Kleisli in the handler.","title":"Building Request Handlers"},{"location":"show-me-the-code/#accessing-request-traits","text":"Traits are attributes associated with the request. Header values, query parameters, path components, request body are all examples of traits. The trait values are accessed using the get function. someHandler :: Have [ PathVar \"widgetId\" UUID , JSONRequestBody Widget , QueryParam \"limit\" Integer ] r => Handler r a someHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget wid = get ( Proxy @ ( PathVar \"widgetId\" UUID )) req -- wid :: UUID limit = get ( Proxy @ ( QueryParam \"limit\" Integer )) req -- limit :: Integer ... return noContent204","title":"Accessing Request Traits"},{"location":"show-me-the-code/#sending-responses","text":"The response value returned contains the HTTP status code, response headers, and optionally a body. The body can be any type that can be converted to a lazy ByteString using the ToByteString type class. createWidget = Kleisli $ \\ req -> do ... return ( created201 widget ) In addition to functions such as ok200 and created201 , there is a generic respond function that accepts an HTTP status code, response headers and the body to generate a response.","title":"Sending Responses"},{"location":"show-me-the-code/#routing-without-templatehaskell","text":"You can use regular functions instead of TemplateHaskell QuasiQuoters for routing if you prefer that. -- matches GET /hello/name:String helloRoute :: Handler '[] String helloRoute = method @ GET $ path @ \"hello\" $ pathVar @ \"name\" @ String $ Kleisli $ \\ req -> do let name = get ( Proxy @ ( PathVar \"name\" String )) req return $ ok200 $ \"Hello, \" ++ name","title":"Routing without TemplateHaskell"},{"location":"show-me-the-code/#composable-routes","text":"Compose routes with <|> . During request routing, each of these routes will be tried sequentially and the first matching handler will be called. allRoutes :: Handler r a allRoutes = createWidget <|> getWidget <|> updateWidget <|> deleteWidget Since handlers are functions, you can refactor and compose them as you wish. The below example shows an application with v1 and v2 path prefixes. allRoutes :: Handler r a allRoutes = v1Routes <|> v2Routes -- matches any path starting with /v1 v1Routes :: Handler r a v1Routes = [ match | / v1 ] $ v1CreateWidget <|> v1GetWidget <|> v1UpdateWidget <|> v1DeleteWidget -- matches any path starting with /v2 v2Routes :: Handler r a v2Routes = [ match | / v2 ] $ v2CreateWidget <|> v2GetWidget <|> v2UpdateWidget <|> v2DeleteWidget","title":"Composable routes"},{"location":"show-me-the-code/#middlewares","text":"Middlewares are handlers that wrap another handler. They usually modify or enhance the behaviour of the inner handler. For example, the queryParam middleware ensures that the inner handler is invoked only when the request contains a query parameter named limit . searchWidget :: Handler '[] a searchWidget = queryParam @ \"limit\" @ Int searchHandler searchHandler :: Has ( QueryParam \"limit\" Int ) r => Handler r a searchHandler = ... Typically, you will compose many middlewares to form a route handler. The user guide explains how you can build your own middlewares.","title":"Middlewares"},{"location":"show-me-the-code/#first-class-json-support","text":"Use JSON input and output in your handlers without any boilerplate. WebGear uses the aeson library to handle JSON values. The request body can be read as a JSON value using jsonRequestBody middleware. The response can be converted to a lazy ByteString using the jsonResponseBody middleware. updateWidget :: Handler '[] ByteString updateWidget = jsonRequestBody @ Widget $ jsonResponseBody @ Widget $ updateWidgetHandler updateWidgetHandler :: Has ( JSONRequestBody Widget ) r => Handler r Widget updateWidgetHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget ... return $ ok200 widget","title":"First-class JSON support"},{"location":"guide/choosing-a-monad/","text":"Choosing a Monad \u00b6 So far, all our handlers used the Handler type which in turn used the Router monad. But this won't work if you want to use your own monad transformer stack or an algebraic effect system. How do we solve that? Type of Handlers \u00b6 The handler and middleware types are defined as: type Handler' m req a = Kleisli m ( Linked req Request ) ( Response a ) type Handler req a = Handler' Router req a type Middleware' m req req' a' a = Handler' m req' a' -> Handler' m req a type Middleware req req' a' a = Middleware' Router req req' a' a You can use any monad of your choice m with a Handler' or Middleware' . However, m must be an instance of MonadRouter to make use of the routing features. You could build such an instance for your monad. However, it is a lot easier if you can find a way to transform monadic values in m to Router . Transformations \u00b6 There is a function for that! transform :: ( forall x . m x -> Router x ) -> ( Handler' m req a -> Handler' Router req a ) transform = ... You provide a function that can translate values in your monad m to values in Router . And now you can translate handlers in your custom monad to handlers in Router monad. Isn't that handy? For example, if you want to use the getWidget route from the previous section with your own monad stack, this is what you would do: getWidget :: Handler' Router req a getWidget = method @ GET $ path @ \"/v1/widgets\" $ pathVar @ \"widgetId\" @ Int $ pathEnd $ handler getWidgetHandler handler :: Handler' ( ReaderT env IO ) req a -> Handler' Router req a handler = transform readerToRouter readerToRouter :: ReaderT env IO a -> Router a readerToRouter = liftIO . flip runReaderT env","title":"Choosing a Monad"},{"location":"guide/choosing-a-monad/#choosing-a-monad","text":"So far, all our handlers used the Handler type which in turn used the Router monad. But this won't work if you want to use your own monad transformer stack or an algebraic effect system. How do we solve that?","title":"Choosing a Monad"},{"location":"guide/choosing-a-monad/#type-of-handlers","text":"The handler and middleware types are defined as: type Handler' m req a = Kleisli m ( Linked req Request ) ( Response a ) type Handler req a = Handler' Router req a type Middleware' m req req' a' a = Handler' m req' a' -> Handler' m req a type Middleware req req' a' a = Middleware' Router req req' a' a You can use any monad of your choice m with a Handler' or Middleware' . However, m must be an instance of MonadRouter to make use of the routing features. You could build such an instance for your monad. However, it is a lot easier if you can find a way to transform monadic values in m to Router .","title":"Type of Handlers"},{"location":"guide/choosing-a-monad/#transformations","text":"There is a function for that! transform :: ( forall x . m x -> Router x ) -> ( Handler' m req a -> Handler' Router req a ) transform = ... You provide a function that can translate values in your monad m to values in Router . And now you can translate handlers in your custom monad to handlers in Router monad. Isn't that handy? For example, if you want to use the getWidget route from the previous section with your own monad stack, this is what you would do: getWidget :: Handler' Router req a getWidget = method @ GET $ path @ \"/v1/widgets\" $ pathVar @ \"widgetId\" @ Int $ pathEnd $ handler getWidgetHandler handler :: Handler' ( ReaderT env IO ) req a -> Handler' Router req a handler = transform readerToRouter readerToRouter :: ReaderT env IO a -> Router a readerToRouter = liftIO . flip runReaderT env","title":"Transformations"},{"location":"guide/first-app/","text":"First Application \u00b6 Let us build our first WebGear application. We'll start off with a simple one, the goal of our first application is to respond with the current time for every HTTP request. Modify src/Main.hs to contain the following code. import Control.Monad.IO.Class import Data.Time.Clock import Network.Wai.Handler.Warp import WebGear getTime :: MonadIO m => Kleisli m a ( Response String ) getTime = Kleisli $ \\ request -> do t <- liftIO getCurrentTime return $ ok200 $ show t main :: IO () main = run 3000 ( toApplication getTime ) Build and run the project: Stack stack build stack exec webgear-guide Cabal cabal run webgear-guide Access http://localhost:3000 and the application should return the current UTC time. Let us check the code in detail to understand this clearly. WAI and Warp \u00b6 We will first examine main function. Like many other Haskell web frameworks, WebGear uses WAI and Warp . WAI provides an interface for web applications to interact with web servers. Warp is a web server based on WAI. In the main function, toApplication is used to convert our WebGear handler to a WAI application. This is then passed to run which starts a Warp server serving HTTP requests arriving at port 3000. Handlers \u00b6 Now we turn our attention to getTime . This is where the business logic of our application lives. In WebGear terminology this is called a Handler. There are a number of interesting things going on here. First, this is a function wrapped in Kleisli from Control.Arrow module. These are called Kleisli arrows which is just a fancy term for functions having the type Monad m => a -> m b . So why don't we use just a regular function instead of this Kleisli wrapper? Well, it gives us some useful type class instances such as Alternative and MonadPlus which will come in handy later. We'll see this when we learn about routing. The function inside Kleisli takes a request value as its parameter and produces a monadic response object as its value. We don't make use of the request in this function because we always return the current time. We also don't care about which monad this runs under as long as it is a MonadIO . Finally, the response is produced with ok200 $ show t . As you would have guessed, this generates an HTTP 200 OK response with the body produced by show t . We return a String body in this case, but it can be any type with a ToByteString instance.","title":"First Application"},{"location":"guide/first-app/#first-application","text":"Let us build our first WebGear application. We'll start off with a simple one, the goal of our first application is to respond with the current time for every HTTP request. Modify src/Main.hs to contain the following code. import Control.Monad.IO.Class import Data.Time.Clock import Network.Wai.Handler.Warp import WebGear getTime :: MonadIO m => Kleisli m a ( Response String ) getTime = Kleisli $ \\ request -> do t <- liftIO getCurrentTime return $ ok200 $ show t main :: IO () main = run 3000 ( toApplication getTime ) Build and run the project: Stack stack build stack exec webgear-guide Cabal cabal run webgear-guide Access http://localhost:3000 and the application should return the current UTC time. Let us check the code in detail to understand this clearly.","title":"First Application"},{"location":"guide/first-app/#wai-and-warp","text":"We will first examine main function. Like many other Haskell web frameworks, WebGear uses WAI and Warp . WAI provides an interface for web applications to interact with web servers. Warp is a web server based on WAI. In the main function, toApplication is used to convert our WebGear handler to a WAI application. This is then passed to run which starts a Warp server serving HTTP requests arriving at port 3000.","title":"WAI and Warp"},{"location":"guide/first-app/#handlers","text":"Now we turn our attention to getTime . This is where the business logic of our application lives. In WebGear terminology this is called a Handler. There are a number of interesting things going on here. First, this is a function wrapped in Kleisli from Control.Arrow module. These are called Kleisli arrows which is just a fancy term for functions having the type Monad m => a -> m b . So why don't we use just a regular function instead of this Kleisli wrapper? Well, it gives us some useful type class instances such as Alternative and MonadPlus which will come in handy later. We'll see this when we learn about routing. The function inside Kleisli takes a request value as its parameter and produces a monadic response object as its value. We don't make use of the request in this function because we always return the current time. We also don't care about which monad this runs under as long as it is a MonadIO . Finally, the response is produced with ok200 $ show t . As you would have guessed, this generates an HTTP 200 OK response with the body produced by show t . We return a String body in this case, but it can be any type with a ToByteString instance.","title":"Handlers"},{"location":"guide/introduction/","text":"WebGear User Guide \u00b6 Introduction \u00b6 This guide is designed to help you get started with WebGear. It follows a tutorial style; if you are looking for reference material, see the API documentation . Requirements \u00b6 This guide assumes that you have a good idea of how HTTP APIs work in general. You also need a good understanding of Haskell programming language features such as type classes, monads, monad transformers etc. WebGear uses a small set of GHC Haskell features that are generally considered advanced. But this guide does not assume that you are an expert in these. All such features will be explained in this guide. However, it is assumed that you understand some basic GHC language extensions such as OverloadedStrings , TypeApplications , and FlexibleContexts . A cursory understanding of QuasiQuotes is useful but not essential. You need a working Haskell development environment with either stack or cabal . If you are using cabal, use GHC version 8.8.4. Quickstart \u00b6 Let us set up a project first. Create a project \u00b6 Stack stack new webgear-guide simple --resolver lts-16.12 cd webgear-guide Cabal cabal update mkdir webgear-guide cd webgear-guide cabal init --application-dir = src Adjust dependencies \u00b6 Edit webgear-guide.cabal and add the following dependencies under build-depends section: build-depends : base ==4.13.0.0 , webgear-server ==0.2.0 , mtl ==2.2.2 , wai ==3.2.2.1 , warp ==3.3.13 , text ==1.2.4.0 , bytestring ==0.10.10.1 , utf8-string ==1.0.1.1 , time ==1.9.3 , unordered-containers ==0.2.10.0 , hashable ==1.3.0.0 , aeson ==1.4.7.1 , http-types ==0.12.3 In addition to this, if you are using stack, add the following to stack.yaml : extra-deps : - webgear-server-0.2.0 Stack stack build Cabal cabal build Tip If this is the first time you are setting up the project, it will take a long time to download and build the dependencies. Subsequent builds will use cached artifacts and will be faster.","title":"Introduction"},{"location":"guide/introduction/#webgear-user-guide","text":"","title":"WebGear User Guide"},{"location":"guide/introduction/#introduction","text":"This guide is designed to help you get started with WebGear. It follows a tutorial style; if you are looking for reference material, see the API documentation .","title":"Introduction"},{"location":"guide/introduction/#requirements","text":"This guide assumes that you have a good idea of how HTTP APIs work in general. You also need a good understanding of Haskell programming language features such as type classes, monads, monad transformers etc. WebGear uses a small set of GHC Haskell features that are generally considered advanced. But this guide does not assume that you are an expert in these. All such features will be explained in this guide. However, it is assumed that you understand some basic GHC language extensions such as OverloadedStrings , TypeApplications , and FlexibleContexts . A cursory understanding of QuasiQuotes is useful but not essential. You need a working Haskell development environment with either stack or cabal . If you are using cabal, use GHC version 8.8.4.","title":"Requirements"},{"location":"guide/introduction/#quickstart","text":"Let us set up a project first.","title":"Quickstart"},{"location":"guide/introduction/#create-a-project","text":"Stack stack new webgear-guide simple --resolver lts-16.12 cd webgear-guide Cabal cabal update mkdir webgear-guide cd webgear-guide cabal init --application-dir = src","title":"Create a project"},{"location":"guide/introduction/#adjust-dependencies","text":"Edit webgear-guide.cabal and add the following dependencies under build-depends section: build-depends : base ==4.13.0.0 , webgear-server ==0.2.0 , mtl ==2.2.2 , wai ==3.2.2.1 , warp ==3.3.13 , text ==1.2.4.0 , bytestring ==0.10.10.1 , utf8-string ==1.0.1.1 , time ==1.9.3 , unordered-containers ==0.2.10.0 , hashable ==1.3.0.0 , aeson ==1.4.7.1 , http-types ==0.12.3 In addition to this, if you are using stack, add the following to stack.yaml : extra-deps : - webgear-server-0.2.0 Stack stack build Cabal cabal build Tip If this is the first time you are setting up the project, it will take a long time to download and build the dependencies. Subsequent builds will use cached artifacts and will be faster.","title":"Adjust dependencies"},{"location":"guide/middlewares/","text":"Middlewares \u00b6 Middlewares are functions that take a handler as their input and produces a handler as output. They are useful to enhance behaviour of handlers. type Middleware req req' a' a = Handler req' a' -> Handler req a We already met the queryParam function in the previous section which is a middleware. Here is possible implementation for it in pseudo-code: queryParam :: ( KnownSymbol name , FromHttpApiData val ) => Middleware req ( QueryParam name val : req ) a a queryParam handler = Kleisli $ \\ request -> do res <- probe @ ( QueryParam name val ) request either sendErrorResponse ( runKleisli handler ) res As you can see, this just uses probe as mentioned in the previous section in an attempt to prove the presence of the QueryParam trait. If successful, we call handler with that result and if unsuccessful, use sendErrorResponse to handle it. Types of Middlewares \u00b6 So what are the kind of things we can do in a middleware? As seen in the queryParam example, we can modify the request parameter passed to the inner handler. Such middlewares are called request middlewares and have this type: type RequestMiddleware req req' a = Middleware req req' a a Similarly, we have response middlewares which modify the responses sent from the inner handler. type ResponseMiddleware req a' a = Middleware req req a' a Of course, we could have a middleware that modifies both the request and response.","title":"Middlewares"},{"location":"guide/middlewares/#middlewares","text":"Middlewares are functions that take a handler as their input and produces a handler as output. They are useful to enhance behaviour of handlers. type Middleware req req' a' a = Handler req' a' -> Handler req a We already met the queryParam function in the previous section which is a middleware. Here is possible implementation for it in pseudo-code: queryParam :: ( KnownSymbol name , FromHttpApiData val ) => Middleware req ( QueryParam name val : req ) a a queryParam handler = Kleisli $ \\ request -> do res <- probe @ ( QueryParam name val ) request either sendErrorResponse ( runKleisli handler ) res As you can see, this just uses probe as mentioned in the previous section in an attempt to prove the presence of the QueryParam trait. If successful, we call handler with that result and if unsuccessful, use sendErrorResponse to handle it.","title":"Middlewares"},{"location":"guide/middlewares/#types-of-middlewares","text":"So what are the kind of things we can do in a middleware? As seen in the queryParam example, we can modify the request parameter passed to the inner handler. Such middlewares are called request middlewares and have this type: type RequestMiddleware req req' a = Middleware req req' a a Similarly, we have response middlewares which modify the responses sent from the inner handler. type ResponseMiddleware req a' a = Middleware req req a' a Of course, we could have a middleware that modifies both the request and response.","title":"Types of Middlewares"},{"location":"guide/next-steps/","text":"Next Steps \u00b6 We have covered all the interesting features of WebGear in this guide. Here is some more information to guide you further. You can find a few example programs in the source repository . These will give you a good idea how this library is used. API reference documentation is available in haddock format in hackage . We also have some benchmarks against other popular Haskell libraries. You may find the benchmark results here . Take these results with a pinch of salt. Typical real world applications could have very different performance characteristics depending on a number of other factors. If in doubt, you should benchmark your application and not rely too much on microbenchmarks such as these.","title":"Next Steps"},{"location":"guide/next-steps/#next-steps","text":"We have covered all the interesting features of WebGear in this guide. Here is some more information to guide you further. You can find a few example programs in the source repository . These will give you a good idea how this library is used. API reference documentation is available in haddock format in hackage . We also have some benchmarks against other popular Haskell libraries. You may find the benchmark results here . Take these results with a pinch of salt. Typical real world applications could have very different performance characteristics depending on a number of other factors. If in doubt, you should benchmark your application and not rely too much on microbenchmarks such as these.","title":"Next Steps"},{"location":"guide/routing/","text":"Routing \u00b6 The applications we built so far had a single handler. However, most web applications will have many handlers each one for serving different HTTP methods, URL paths etc. Let us see how to achieve this in WebGear. Alternatives \u00b6 We know that handlers are kleisli arrows. This means that we can combine multiple handlers using the <|> operator from Alternative type class. Thus, if we have two handlers getTime and setTime , we could create a combined handler like this. timeHandler = getTime <|> setTime So, how do we decide which handler gets invoked for a given request? How do we \"route\" a request to a specific handler? It turns out we can do this using a middleware. Router Monad \u00b6 As explained in the traits section, handler are kleisli arrows on the Router monad. However, it is useful to look at the MonadRouter type class instead of using this monad directly. class ( Alternative m , MonadPlus m ) => MonadRouter m where -- | Mark the current route as rejected, alternatives can be tried rejectRoute :: m a -- | Short-circuit the current handler and return a response errorResponse :: Response ByteString -> m a -- | Handle an error response catchErrorResponse :: m a -> ( Response ByteString -> m a ) -> m a The rejectRoute method can be used by middlewares and handlers to flag the current route as \"not matching\", so that the next route is tried. This forms the basis of routing. For example, given this code: -- Reject the route so that alternatives will be tried method :: MonadRouter m => Middleware' m req ( Method t : req ) a a method handler = Kleisli $ \\ request -> do res <- probe @ ( Method t ) request either ( const rejectRoute ) ( runKleisli handler ) res timeHandler = getTime <|> setTime getTime :: Handler req a getTime = method @ GET getTimeHandler setTime :: Handler req a setTime = method @ POST setTimeHandler The MonadRouter will try each route sequentially. If any of them calls rejectRoute , the next one will be tried and the response from the first matching handler will be returned. If none of the route handlers matched, a 404 Not Found response will be returned. The errorResponse and catchErrorResponse are used in cases where you want to indicate that the current handler matches the route but you want to return an exceptional response. This is similar to the exception handling mechanisms offered by the MonadError type class. Middlewares for Routing \u00b6 As you can see from the above description, the routing mechanism is very flexible in WebGear. Virtually any middleware or handler can invoke rejectRoute to skip the current handler and try the next. WebGear does not assume anything about which request attributes are used in the handler selection. That decision is left to middlewares and handlers. However, for most use cases, you want to route based on the HTTP method and/or the URL path. WebGear provides a number of middlewares that support this common use case. method attempts to match an HTTP method. path attempts to match a prefix portion of the request URL path. pathVar attempts to parse the next component from the URL path to a value via FromHttpApiData type class. pathEnd succeeds only if all URL path components are already consumed by path or pathVar Here is how you would use them: -- Matches a GET request on URL /v1/widgets/<widgetId> -- where <widgetId> can be parsed as an Int getWidget :: Handler req a getWidget = method @ GET $ path @ \"/v1/widgets\" $ pathVar @ \"widgetId\" @ Int $ pathEnd $ getWidgetHandler If you prefer a less verbose version, you can use template haskell quasiquoter: getWidget :: Handler req a getWidget = [ route | GET / v1 / widgets / widgetId :Int | ] getWidgetHandler This version using the route quasiquoter is equivalent to the previous one. There is also the match quasiquoter which is similar to route but does not add the pathEnd middleware. It is useful in cases where only a prefix of the path needs to be matched.","title":"Routing"},{"location":"guide/routing/#routing","text":"The applications we built so far had a single handler. However, most web applications will have many handlers each one for serving different HTTP methods, URL paths etc. Let us see how to achieve this in WebGear.","title":"Routing"},{"location":"guide/routing/#alternatives","text":"We know that handlers are kleisli arrows. This means that we can combine multiple handlers using the <|> operator from Alternative type class. Thus, if we have two handlers getTime and setTime , we could create a combined handler like this. timeHandler = getTime <|> setTime So, how do we decide which handler gets invoked for a given request? How do we \"route\" a request to a specific handler? It turns out we can do this using a middleware.","title":"Alternatives"},{"location":"guide/routing/#router-monad","text":"As explained in the traits section, handler are kleisli arrows on the Router monad. However, it is useful to look at the MonadRouter type class instead of using this monad directly. class ( Alternative m , MonadPlus m ) => MonadRouter m where -- | Mark the current route as rejected, alternatives can be tried rejectRoute :: m a -- | Short-circuit the current handler and return a response errorResponse :: Response ByteString -> m a -- | Handle an error response catchErrorResponse :: m a -> ( Response ByteString -> m a ) -> m a The rejectRoute method can be used by middlewares and handlers to flag the current route as \"not matching\", so that the next route is tried. This forms the basis of routing. For example, given this code: -- Reject the route so that alternatives will be tried method :: MonadRouter m => Middleware' m req ( Method t : req ) a a method handler = Kleisli $ \\ request -> do res <- probe @ ( Method t ) request either ( const rejectRoute ) ( runKleisli handler ) res timeHandler = getTime <|> setTime getTime :: Handler req a getTime = method @ GET getTimeHandler setTime :: Handler req a setTime = method @ POST setTimeHandler The MonadRouter will try each route sequentially. If any of them calls rejectRoute , the next one will be tried and the response from the first matching handler will be returned. If none of the route handlers matched, a 404 Not Found response will be returned. The errorResponse and catchErrorResponse are used in cases where you want to indicate that the current handler matches the route but you want to return an exceptional response. This is similar to the exception handling mechanisms offered by the MonadError type class.","title":"Router Monad"},{"location":"guide/routing/#middlewares-for-routing","text":"As you can see from the above description, the routing mechanism is very flexible in WebGear. Virtually any middleware or handler can invoke rejectRoute to skip the current handler and try the next. WebGear does not assume anything about which request attributes are used in the handler selection. That decision is left to middlewares and handlers. However, for most use cases, you want to route based on the HTTP method and/or the URL path. WebGear provides a number of middlewares that support this common use case. method attempts to match an HTTP method. path attempts to match a prefix portion of the request URL path. pathVar attempts to parse the next component from the URL path to a value via FromHttpApiData type class. pathEnd succeeds only if all URL path components are already consumed by path or pathVar Here is how you would use them: -- Matches a GET request on URL /v1/widgets/<widgetId> -- where <widgetId> can be parsed as an Int getWidget :: Handler req a getWidget = method @ GET $ path @ \"/v1/widgets\" $ pathVar @ \"widgetId\" @ Int $ pathEnd $ getWidgetHandler If you prefer a less verbose version, you can use template haskell quasiquoter: getWidget :: Handler req a getWidget = [ route | GET / v1 / widgets / widgetId :Int | ] getWidgetHandler This version using the route quasiquoter is equivalent to the previous one. There is also the match quasiquoter which is similar to route but does not add the pathEnd middleware. It is useful in cases where only a prefix of the path needs to be matched.","title":"Middlewares for Routing"},{"location":"guide/traits/","text":"Traits \u00b6 The application from the previous section is very rudimentary. Let us enhance it a bit. Instead of always printing the time in UTC, let us accept a query parameter named local and respond with the time in the local time zone when it is set to true. Obviously, this requires extracting a query parameter from the request. So far, we have not looked at the type of requests and operations allowed on them. So let us do that first. Requests \u00b6 The request parameter to handler functions has the type Linked ( req :: [ Type ]) Request . This might look confusing if you are not familiar with type-level programming in Haskell. So here is an explanation. The annotation req :: [ Type ] means that this type parameter is a list of types and not a single type. So Linked [ Bool , Int ] Request is a valid type, but Linked Char Request is not. You must be wondering why we need to \"link\" a request with a list of types. Well, many attributes such as query parameters are optional, they may not exist for a given request or may not have the right type. So instead of checking the presence of an attribute in the request every time we need it, we check it once at the beginning. If this is successful, we record that fact in this list of types req . Such attributes are called traits in WebGear terminology. Query parameters, path variables, headers, HTTP methods are all examples of traits. So how does this work in practice? Here is the modified application supporting a local query parameter. {-# LANGUAGE DataKinds #-} {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TypeApplications #-} import Control.Monad.IO.Class ( MonadIO ( liftIO )) import Data.Time ( getCurrentTime , getZonedTime ) import Network.Wai.Handler.Warp ( run ) import WebGear getTime :: Handler '[] String getTime = queryParam @ \"local\" @ Bool getTimeHandler getTimeHandler :: Has ( QueryParam \"local\" Bool ) req => Handler req String getTimeHandler = Kleisli $ \\ request -> do let local = get ( Proxy @ ( QueryParam \"local\" Bool )) request if local then ok200 . show <$> liftIO getZonedTime else ok200 . show <$> liftIO getCurrentTime main :: IO () main = run 3000 ( toApplication getTime ) Testing curl is a handy tool to test HTTP APIs: curl --get 'http://localhost:3000' --data-urlencode 'local=True' # Local time curl --get 'http://localhost:3000' --data-urlencode 'local=False' # UTC time curl --get 'http://localhost:3000' # 400 Bad Request Handler Type Did you notice that the type of getTime changed from MonadIO m => Kleisli m a ( Response String ) to Handler '[] String ? It is not really a change because Handler is defined as: type Handler req a = Kleisli Router ( Linked req Request ) ( Response a ) Router has a MonadIO instance (besides other functionality), so this is not very different from the previous type. Using Traits \u00b6 Using traits in your API handlers is easy. First, when you start processing the request in your handler, we don't know whether any of the traits that we are interested in is present in the request. So the handler has the type Handler '[] a ; the list of traits is empty. Second, functions such as queryParam verify the presence of a trait and then invoke another handler ( getTimeHandler in the above example). In this case, queryParam invokes getTimeHandler only if the request has the trait QueryParam \"local\" Bool . Presence of this trait indicates that the request has a query parameter named local and it can be parsed to a boolean value. The type of getTimeHandler is Has ( QueryParam \"local\" Bool ) req => Handler req String indicating that it is verified already that the request has the trait. Third, the get function is used to retrieve the value of a trait attribute, in our example, the query parameter value as a Bool . This function can only be used if you have the appropriate Has constraint for your handler. This is a type-safe access mechanism for trait attributes. DataKinds The DataKinds language extension enables promotion of data constructors to type constructors. With this extension, we could use some values as types. For example, we already saw types such as Linked '[] Request and QueryParam \"local\" Bool ; both '[] and \"local\" are used as types here. This extension helps to define expressive APIs in WebGear. Read more about this extension in GHC documentation . Defining Traits \u00b6 Most of the time, you can just use traits defined by WebGear as mentioned above and be done with it. But you can easily define your own traits as well if the traits provided out of the box are insufficient. All you need to do is define a new data type and have an instance of Trait type class. For example, the trait for matching the HTTP method of a request can be defined as: {-# LANGUAGE DataKinds, FlexibleInstances, InstanceSigs, KindSignatures, MultiParamTypeClasses, PolyKinds, ScopedTypeVariables, TypeApplications, TypeFamilies #-} import Data.String ( fromString ) import GHC.TypeLits ( KnownSymbol , Symbol , symbolVal ) import qualified Network.HTTP.Types as HTTP import WebGear data MethodMatch ( t :: Symbol ) instance ( KnownSymbol t , Monad m ) => Trait ( MethodMatch t ) Request m where -- There is nothing interesting to return on success type Attribute ( MethodMatch t ) Request = () -- Return the actual method from the request on a mismatch type Absence ( MethodMatch t ) Request = HTTP . Method toAttribute :: Request -> m ( Result ( MethodMatch t ) Request ) toAttribute request = let expected = fromString $ symbolVal $ Proxy @ t actual = requestMethod request in return $ if expected == actual then Found () else NotFound actual Symbols If you are not familiar with Symbol , symbolVal etc, they introduce type level string literals. All string literals at type level is of kind Symbol . You can use the symbolVal function to convert them to a String value. The Trait type class defined two associated types. The type Attribute is the trait attribute value when the trait is present in the request. The type Absence is used to indicate absence of a trait; this could be some sort of error value. The toAttribute function either returns a Found value with an Attribute on success, or a NotFound value with an Absence on failure. Now we have a way of defining traits and checking their presence in the request. But there is still a missing piece. Our handlers accept a parameter of type Linked req Request . How do we construct a value of this type? Linking \u00b6 As already explained, a Linked req Request value is essentially a request with a list of traits - req - that are known to be present for this request. How does this list get built? Obviously we cannot have a function that adds arbitrary traits to this list. A trait should be added to this list if and only if the toAttribute function returns a Found value. Otherwise, all the type-safety guarantees will be void. This is where linking comes in. These are the functions that let us operate on linked values: link :: a -> Linked '[] a lets us \"promote\" a regular value to a linked value with no traits proven yet on it. Think of this as a first step in starting to work with linked values. unlink :: Linked ts a -> a is the opposite operation. You use it to extract the value out of a linked value. probe :: Trait t a m => Linked ts a -> m ( Either ( Absence t a ) ( Linked ( t : ts ) a )) grows the type level list of traits in a linked value. Given a linked value which has a list of traits already established, this function will probe for another trait t using the toAttribute function. If the trait is found, it will return a Linked ( t : ts ) a value thereby adding the trait to the type level list. If the trait is not present, you get the Absence t a indicating an error. Summary \u00b6 In summary, this is how you use traits: Define a data type T for the trait. Define an instance of Trait type class for this type. In your handlers, add a constraint Has T req , so that you can use get ( Proxy @ T ) request to retrieve the trait value. Use probe to check presence of traits and form linked values. These linked requests can be passed as arguments to handlers.","title":"Traits"},{"location":"guide/traits/#traits","text":"The application from the previous section is very rudimentary. Let us enhance it a bit. Instead of always printing the time in UTC, let us accept a query parameter named local and respond with the time in the local time zone when it is set to true. Obviously, this requires extracting a query parameter from the request. So far, we have not looked at the type of requests and operations allowed on them. So let us do that first.","title":"Traits"},{"location":"guide/traits/#requests","text":"The request parameter to handler functions has the type Linked ( req :: [ Type ]) Request . This might look confusing if you are not familiar with type-level programming in Haskell. So here is an explanation. The annotation req :: [ Type ] means that this type parameter is a list of types and not a single type. So Linked [ Bool , Int ] Request is a valid type, but Linked Char Request is not. You must be wondering why we need to \"link\" a request with a list of types. Well, many attributes such as query parameters are optional, they may not exist for a given request or may not have the right type. So instead of checking the presence of an attribute in the request every time we need it, we check it once at the beginning. If this is successful, we record that fact in this list of types req . Such attributes are called traits in WebGear terminology. Query parameters, path variables, headers, HTTP methods are all examples of traits. So how does this work in practice? Here is the modified application supporting a local query parameter. {-# LANGUAGE DataKinds #-} {-# LANGUAGE FlexibleContexts #-} {-# LANGUAGE OverloadedStrings #-} {-# LANGUAGE TypeApplications #-} import Control.Monad.IO.Class ( MonadIO ( liftIO )) import Data.Time ( getCurrentTime , getZonedTime ) import Network.Wai.Handler.Warp ( run ) import WebGear getTime :: Handler '[] String getTime = queryParam @ \"local\" @ Bool getTimeHandler getTimeHandler :: Has ( QueryParam \"local\" Bool ) req => Handler req String getTimeHandler = Kleisli $ \\ request -> do let local = get ( Proxy @ ( QueryParam \"local\" Bool )) request if local then ok200 . show <$> liftIO getZonedTime else ok200 . show <$> liftIO getCurrentTime main :: IO () main = run 3000 ( toApplication getTime ) Testing curl is a handy tool to test HTTP APIs: curl --get 'http://localhost:3000' --data-urlencode 'local=True' # Local time curl --get 'http://localhost:3000' --data-urlencode 'local=False' # UTC time curl --get 'http://localhost:3000' # 400 Bad Request Handler Type Did you notice that the type of getTime changed from MonadIO m => Kleisli m a ( Response String ) to Handler '[] String ? It is not really a change because Handler is defined as: type Handler req a = Kleisli Router ( Linked req Request ) ( Response a ) Router has a MonadIO instance (besides other functionality), so this is not very different from the previous type.","title":"Requests"},{"location":"guide/traits/#using-traits","text":"Using traits in your API handlers is easy. First, when you start processing the request in your handler, we don't know whether any of the traits that we are interested in is present in the request. So the handler has the type Handler '[] a ; the list of traits is empty. Second, functions such as queryParam verify the presence of a trait and then invoke another handler ( getTimeHandler in the above example). In this case, queryParam invokes getTimeHandler only if the request has the trait QueryParam \"local\" Bool . Presence of this trait indicates that the request has a query parameter named local and it can be parsed to a boolean value. The type of getTimeHandler is Has ( QueryParam \"local\" Bool ) req => Handler req String indicating that it is verified already that the request has the trait. Third, the get function is used to retrieve the value of a trait attribute, in our example, the query parameter value as a Bool . This function can only be used if you have the appropriate Has constraint for your handler. This is a type-safe access mechanism for trait attributes. DataKinds The DataKinds language extension enables promotion of data constructors to type constructors. With this extension, we could use some values as types. For example, we already saw types such as Linked '[] Request and QueryParam \"local\" Bool ; both '[] and \"local\" are used as types here. This extension helps to define expressive APIs in WebGear. Read more about this extension in GHC documentation .","title":"Using Traits"},{"location":"guide/traits/#defining-traits","text":"Most of the time, you can just use traits defined by WebGear as mentioned above and be done with it. But you can easily define your own traits as well if the traits provided out of the box are insufficient. All you need to do is define a new data type and have an instance of Trait type class. For example, the trait for matching the HTTP method of a request can be defined as: {-# LANGUAGE DataKinds, FlexibleInstances, InstanceSigs, KindSignatures, MultiParamTypeClasses, PolyKinds, ScopedTypeVariables, TypeApplications, TypeFamilies #-} import Data.String ( fromString ) import GHC.TypeLits ( KnownSymbol , Symbol , symbolVal ) import qualified Network.HTTP.Types as HTTP import WebGear data MethodMatch ( t :: Symbol ) instance ( KnownSymbol t , Monad m ) => Trait ( MethodMatch t ) Request m where -- There is nothing interesting to return on success type Attribute ( MethodMatch t ) Request = () -- Return the actual method from the request on a mismatch type Absence ( MethodMatch t ) Request = HTTP . Method toAttribute :: Request -> m ( Result ( MethodMatch t ) Request ) toAttribute request = let expected = fromString $ symbolVal $ Proxy @ t actual = requestMethod request in return $ if expected == actual then Found () else NotFound actual Symbols If you are not familiar with Symbol , symbolVal etc, they introduce type level string literals. All string literals at type level is of kind Symbol . You can use the symbolVal function to convert them to a String value. The Trait type class defined two associated types. The type Attribute is the trait attribute value when the trait is present in the request. The type Absence is used to indicate absence of a trait; this could be some sort of error value. The toAttribute function either returns a Found value with an Attribute on success, or a NotFound value with an Absence on failure. Now we have a way of defining traits and checking their presence in the request. But there is still a missing piece. Our handlers accept a parameter of type Linked req Request . How do we construct a value of this type?","title":"Defining Traits"},{"location":"guide/traits/#linking","text":"As already explained, a Linked req Request value is essentially a request with a list of traits - req - that are known to be present for this request. How does this list get built? Obviously we cannot have a function that adds arbitrary traits to this list. A trait should be added to this list if and only if the toAttribute function returns a Found value. Otherwise, all the type-safety guarantees will be void. This is where linking comes in. These are the functions that let us operate on linked values: link :: a -> Linked '[] a lets us \"promote\" a regular value to a linked value with no traits proven yet on it. Think of this as a first step in starting to work with linked values. unlink :: Linked ts a -> a is the opposite operation. You use it to extract the value out of a linked value. probe :: Trait t a m => Linked ts a -> m ( Either ( Absence t a ) ( Linked ( t : ts ) a )) grows the type level list of traits in a linked value. Given a linked value which has a list of traits already established, this function will probe for another trait t using the toAttribute function. If the trait is found, it will return a Linked ( t : ts ) a value thereby adding the trait to the type level list. If the trait is not present, you get the Absence t a indicating an error.","title":"Linking"},{"location":"guide/traits/#summary","text":"In summary, this is how you use traits: Define a data type T for the trait. Define an instance of Trait type class for this type. In your handlers, add a constraint Has T req , so that you can use get ( Proxy @ T ) request to retrieve the trait value. Use probe to check presence of traits and form linked values. These linked requests can be passed as arguments to handlers.","title":"Summary"}]}