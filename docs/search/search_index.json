{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to WebGear \u00b6 WebGear makes it easy to build composable, extensible, type-Safe HTTP APIs in Haskell. Show me the code! User Guide Hello WebGear \u00b6 Here is a fully functional WebGear application. If you access http://localhost:3000/hello/Legolas , you'd get a 200 OK response with body: Hello, Legolas . {-# LANGUAGE DataKinds, QuasiQuotes, TypeApplications #-} import Network.HTTP.Types ( StdMethod ( GET )) import Network.Wai.Handler.Warp import WebGear routes :: Handler '[] String routes = [ route | GET / hello / name :String | ] $ Kleisli $ \\ request -> do let name = get ( Proxy @ ( PathVar \"name\" String )) request return $ ok200 $ \"Hello, \" ++ name main :: IO () main = run 3000 ( toApplication routes ) Developer Friendly \u00b6 WebGear is built on a small number of simple concepts which makes it approachable. You don't need to understand a gazillion advanced language features to build type safe APIs. Friendly error messages will guide you when you make mistakes. Composability \u00b6 APIs are built by composing functions to form handlers and middlewares. Build complex APIs from smaller simpler parts! putUser = method @ PUT $ requestContentTypeHeader @ \"application/json\" $ jsonRequestBody @ User $ jsonResponseBody @ User $ putUserHandler Extensibility \u00b6 Every component of WebGear can be replaced with alternative implementations should you wish so. Your custom middlewares are as first-class as the ones provided by WebGear. APIs run with the framework of your choice. WebGear can work with monad transformers or algebraic effect systems that you want to use. Continue to learn more about WebGear. Show me the code! User Guide","title":"Home"},{"location":"#welcome-to-webgear","text":"WebGear makes it easy to build composable, extensible, type-Safe HTTP APIs in Haskell. Show me the code! User Guide","title":"Welcome to WebGear"},{"location":"#hello-webgear","text":"Here is a fully functional WebGear application. If you access http://localhost:3000/hello/Legolas , you'd get a 200 OK response with body: Hello, Legolas . {-# LANGUAGE DataKinds, QuasiQuotes, TypeApplications #-} import Network.HTTP.Types ( StdMethod ( GET )) import Network.Wai.Handler.Warp import WebGear routes :: Handler '[] String routes = [ route | GET / hello / name :String | ] $ Kleisli $ \\ request -> do let name = get ( Proxy @ ( PathVar \"name\" String )) request return $ ok200 $ \"Hello, \" ++ name main :: IO () main = run 3000 ( toApplication routes )","title":"Hello WebGear"},{"location":"#developer-friendly","text":"WebGear is built on a small number of simple concepts which makes it approachable. You don't need to understand a gazillion advanced language features to build type safe APIs. Friendly error messages will guide you when you make mistakes.","title":"Developer Friendly"},{"location":"#composability","text":"APIs are built by composing functions to form handlers and middlewares. Build complex APIs from smaller simpler parts! putUser = method @ PUT $ requestContentTypeHeader @ \"application/json\" $ jsonRequestBody @ User $ jsonResponseBody @ User $ putUserHandler","title":"Composability"},{"location":"#extensibility","text":"Every component of WebGear can be replaced with alternative implementations should you wish so. Your custom middlewares are as first-class as the ones provided by WebGear. APIs run with the framework of your choice. WebGear can work with monad transformers or algebraic effect systems that you want to use. Continue to learn more about WebGear. Show me the code! User Guide","title":"Extensibility"},{"location":"show-me-the-code/","text":"Show me some code! \u00b6 This is a whirlwind tour of WebGear. If you want to learn more, go to the user guide . Building Request Handlers \u00b6 A request handler is just a function that takes a request value and produces a response value in a monadic context. This is where the business logic of your application lives. -- The 'Has (JSONRequestBody Widget) r' constrait indicates that this handler -- can only be called if the request body is a valid JSON that can be parsed -- to a Widget value. putWidget :: Has ( JSONRequestBody Widget ) r => Handler r Widget putWidget = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req saveToDB widget return ( ok200 widget ) The Handler req Widget type in the example above is equivalent to the function type Monad m => Linked req Request -> m ( Response Widget ) in principle. These type of functions are also known as Kleisli arrows; hence the use of Kleisli in the handler. Accessing Request Traits \u00b6 Traits are attributes associated with the request. Header values, query parameters, path components, request body are all examples of traits. The trait values are accessed using the get function. someHandler :: Have [ PathVar \"widgetId\" UUID , JSONRequestBody Widget , QueryParam \"limit\" Integer ] r => Handler r a someHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget wid = get ( Proxy @ ( PathVar \"widgetId\" UUID )) req -- wid :: UUID limit = get ( Proxy @ ( QueryParam \"limit\" Integer )) req -- limit :: Integer ... return noContent204 Sending Responses \u00b6 The response value returned contains the HTTP status code, response headers, and optionally a body. The body can be any type that can be converted to a lazy ByteString using the ToByteString type class. createWidget = Kleisli $ \\ req -> do ... return ( created201 widget ) In addition to functions such as ok200 and created201 , there is a generic respond function that accepts an HTTP status code, response headers and the body to generate a response. Routing without TemplateHaskell \u00b6 You can use regular functions instead of TemplateHaskell QuasiQuotes for routing if you prefer that. -- matches GET /hello/name:String helloRoute :: Handler '[] String helloRoute = method @ GET $ path @ \"hello\" $ pathVar @ \"name\" @ String $ Kleisli $ \\ req -> do let name = get ( Proxy @ ( PathVar \"name\" String )) req return $ ok200 $ \"Hello, \" ++ name Composable routes \u00b6 Compose routes with <|> . During request routing, each of these routes will be tried sequentially and the first matching handler will be called. allRoutes :: Handler r a allRoutes = createWidget <|> getWidget <|> updateWidget <|> deleteWidget Since handlers are functions, you can refactor and compose them as you wish. The below example shows an application with v1 and v2 path prefixes. allRoutes :: Handler r a allRoutes = v1Routes <|> v2Routes -- matches any path starting with /v1 v1Routes :: Handler r a v1Routes = [ match | / v1 ] $ v1CreateWidget <|> v1GetWidget <|> v1UpdateWidget <|> v1DeleteWidget -- matches any path starting with /v2 v2Routes :: Handler r a v2Routes = [ match | / v2 ] $ v2CreateWidget <|> v2GetWidget <|> v2UpdateWidget <|> v2DeleteWidget Middlewares \u00b6 Middlewares are handlers that wrap another handler. They usually modify or enhance the bahaviour of the inner handler. For example, the queryParam middleware ensures that the inner handler is invoked only when the request contains a query parameter named limit . searchWidget :: Handler '[] a searchWidget = queryParam @ \"limit\" @ Int searchHandler searchHandler :: Has ( QueryParam \"limit\" Int ) r => Handler r a searchHandler = ... Typically you will compose many middlewares to form a route handler. The user guide explains how you can build your own middlewares. First-class JSON support \u00b6 Use JSON input and output in your handlers without any boilerplate. WebGear uses the aeson library to handle JSON values. The request body can be read as a JSON value using jsonRequestBody middleware. The response can be converted to a lazy ByteString using the jsonResponseBody middleware. updateWidget :: Handler '[] ByteString updateWidget = jsonRequestBody @ Widget $ jsonResponseBody @ Widget $ updateWidgetHandler updateWidgetHandler :: Has ( JSONRequestBody Widget ) r => Handler r Widget updateWidgetHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget ... return $ ok200 widget","title":"Show me the code!"},{"location":"show-me-the-code/#show-me-some-code","text":"This is a whirlwind tour of WebGear. If you want to learn more, go to the user guide .","title":"Show me some code!"},{"location":"show-me-the-code/#building-request-handlers","text":"A request handler is just a function that takes a request value and produces a response value in a monadic context. This is where the business logic of your application lives. -- The 'Has (JSONRequestBody Widget) r' constrait indicates that this handler -- can only be called if the request body is a valid JSON that can be parsed -- to a Widget value. putWidget :: Has ( JSONRequestBody Widget ) r => Handler r Widget putWidget = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req saveToDB widget return ( ok200 widget ) The Handler req Widget type in the example above is equivalent to the function type Monad m => Linked req Request -> m ( Response Widget ) in principle. These type of functions are also known as Kleisli arrows; hence the use of Kleisli in the handler.","title":"Building Request Handlers"},{"location":"show-me-the-code/#accessing-request-traits","text":"Traits are attributes associated with the request. Header values, query parameters, path components, request body are all examples of traits. The trait values are accessed using the get function. someHandler :: Have [ PathVar \"widgetId\" UUID , JSONRequestBody Widget , QueryParam \"limit\" Integer ] r => Handler r a someHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget wid = get ( Proxy @ ( PathVar \"widgetId\" UUID )) req -- wid :: UUID limit = get ( Proxy @ ( QueryParam \"limit\" Integer )) req -- limit :: Integer ... return noContent204","title":"Accessing Request Traits"},{"location":"show-me-the-code/#sending-responses","text":"The response value returned contains the HTTP status code, response headers, and optionally a body. The body can be any type that can be converted to a lazy ByteString using the ToByteString type class. createWidget = Kleisli $ \\ req -> do ... return ( created201 widget ) In addition to functions such as ok200 and created201 , there is a generic respond function that accepts an HTTP status code, response headers and the body to generate a response.","title":"Sending Responses"},{"location":"show-me-the-code/#routing-without-templatehaskell","text":"You can use regular functions instead of TemplateHaskell QuasiQuotes for routing if you prefer that. -- matches GET /hello/name:String helloRoute :: Handler '[] String helloRoute = method @ GET $ path @ \"hello\" $ pathVar @ \"name\" @ String $ Kleisli $ \\ req -> do let name = get ( Proxy @ ( PathVar \"name\" String )) req return $ ok200 $ \"Hello, \" ++ name","title":"Routing without TemplateHaskell"},{"location":"show-me-the-code/#composable-routes","text":"Compose routes with <|> . During request routing, each of these routes will be tried sequentially and the first matching handler will be called. allRoutes :: Handler r a allRoutes = createWidget <|> getWidget <|> updateWidget <|> deleteWidget Since handlers are functions, you can refactor and compose them as you wish. The below example shows an application with v1 and v2 path prefixes. allRoutes :: Handler r a allRoutes = v1Routes <|> v2Routes -- matches any path starting with /v1 v1Routes :: Handler r a v1Routes = [ match | / v1 ] $ v1CreateWidget <|> v1GetWidget <|> v1UpdateWidget <|> v1DeleteWidget -- matches any path starting with /v2 v2Routes :: Handler r a v2Routes = [ match | / v2 ] $ v2CreateWidget <|> v2GetWidget <|> v2UpdateWidget <|> v2DeleteWidget","title":"Composable routes"},{"location":"show-me-the-code/#middlewares","text":"Middlewares are handlers that wrap another handler. They usually modify or enhance the bahaviour of the inner handler. For example, the queryParam middleware ensures that the inner handler is invoked only when the request contains a query parameter named limit . searchWidget :: Handler '[] a searchWidget = queryParam @ \"limit\" @ Int searchHandler searchHandler :: Has ( QueryParam \"limit\" Int ) r => Handler r a searchHandler = ... Typically you will compose many middlewares to form a route handler. The user guide explains how you can build your own middlewares.","title":"Middlewares"},{"location":"show-me-the-code/#first-class-json-support","text":"Use JSON input and output in your handlers without any boilerplate. WebGear uses the aeson library to handle JSON values. The request body can be read as a JSON value using jsonRequestBody middleware. The response can be converted to a lazy ByteString using the jsonResponseBody middleware. updateWidget :: Handler '[] ByteString updateWidget = jsonRequestBody @ Widget $ jsonResponseBody @ Widget $ updateWidgetHandler updateWidgetHandler :: Has ( JSONRequestBody Widget ) r => Handler r Widget updateWidgetHandler = Kleisli $ \\ req -> do let widget = get ( Proxy @ ( JSONRequestBody Widget )) req -- widget :: Widget ... return $ ok200 widget","title":"First-class JSON support"},{"location":"guide/first-app/","text":"First Application \u00b6 Let us build our first WebGear application. We'll start off with a simple one, the goal of our first application is to respond with the current time for every HTTP request. Modify src/Main.hs to contain the following code. import Control.Monad.IO.Class import Data.Time.Clock import Network.Wai.Handler.Warp import WebGear getTime :: MonadIO m => Kleisli m a ( Response String ) getTime = Kleisli $ \\ request -> do t <- liftIO getCurrentTime return $ ok200 $ show t main :: IO () main = run 3000 ( toApplication getTime ) Build and run the project: Stack stack build stack exec webgear-guide Cabal cabal run webgear-guide Access http://localhost:3000 and the application should return the current UTC time. Let us check the code in detail to understand this clearly. WAI and Warp \u00b6 We will first examine main function. Like many other Haskell web frameworks, WebGear uses WAI and Warp . WAI provides an interface for web applications to interact with web servers. Warp is a web server based on WAI. In the main function, toApplication is used to convert our WebGear handler to a WAI application. This is then passed to run which starts a Warp server serving HTTP requests arriving on port 3000. Handlers \u00b6 Now we turn our attention to getTime . This is where the business logic of our application lives. In WebGear terminology this is called a Handler. There are a number of interesting things going on here. First of all, this is a function wrapped in Kleisli from Control.Arrow module. These are called Kleisli arrows which is just a fancy term for functions having the type Monad m => a -> m b . So why don't we use just a regular function instead of this Kleisli wrapper? Well, it gives us some useful type class instances such as Alternative and MonadPlus which will come in handy later. We'll see this when we learn about routing. The function inside Kleisli takes a request value as its parameter and produces a monadic response object as its value. We don't make use of the request in this function because we always return the current time. We also don't care about which monad this runs under as long as it is a MonadIO . Finally, the response is produced with ok200 $ show t . As you would have guessed, this generates an HTTP 200 OK response with the body produced by show t . We returns a String body in this case, but it can be any type with a ToByteString instance.","title":"First Application"},{"location":"guide/first-app/#first-application","text":"Let us build our first WebGear application. We'll start off with a simple one, the goal of our first application is to respond with the current time for every HTTP request. Modify src/Main.hs to contain the following code. import Control.Monad.IO.Class import Data.Time.Clock import Network.Wai.Handler.Warp import WebGear getTime :: MonadIO m => Kleisli m a ( Response String ) getTime = Kleisli $ \\ request -> do t <- liftIO getCurrentTime return $ ok200 $ show t main :: IO () main = run 3000 ( toApplication getTime ) Build and run the project: Stack stack build stack exec webgear-guide Cabal cabal run webgear-guide Access http://localhost:3000 and the application should return the current UTC time. Let us check the code in detail to understand this clearly.","title":"First Application"},{"location":"guide/first-app/#wai-and-warp","text":"We will first examine main function. Like many other Haskell web frameworks, WebGear uses WAI and Warp . WAI provides an interface for web applications to interact with web servers. Warp is a web server based on WAI. In the main function, toApplication is used to convert our WebGear handler to a WAI application. This is then passed to run which starts a Warp server serving HTTP requests arriving on port 3000.","title":"WAI and Warp"},{"location":"guide/first-app/#handlers","text":"Now we turn our attention to getTime . This is where the business logic of our application lives. In WebGear terminology this is called a Handler. There are a number of interesting things going on here. First of all, this is a function wrapped in Kleisli from Control.Arrow module. These are called Kleisli arrows which is just a fancy term for functions having the type Monad m => a -> m b . So why don't we use just a regular function instead of this Kleisli wrapper? Well, it gives us some useful type class instances such as Alternative and MonadPlus which will come in handy later. We'll see this when we learn about routing. The function inside Kleisli takes a request value as its parameter and produces a monadic response object as its value. We don't make use of the request in this function because we always return the current time. We also don't care about which monad this runs under as long as it is a MonadIO . Finally, the response is produced with ok200 $ show t . As you would have guessed, this generates an HTTP 200 OK response with the body produced by show t . We returns a String body in this case, but it can be any type with a ToByteString instance.","title":"Handlers"},{"location":"guide/introduction/","text":"WebGear User Guide \u00b6 Introduction \u00b6 WebGear is a library to build composable, extensible, type-safe APIs. This guide is designed to help you get started with WebGear. It follows a tutorial style; if you are looking for reference material, see the API documentation . Requirements \u00b6 You need a good understanding of Haskell programming language features such as type classes, monads, monad transformers to follow along this guide. WebGear uses a small set of GHC haskell features that are generally considered advanced. But this guide does not assume that you are an expert in these. All such features will be explained in this guide. However, it is assumed that you understand some basic GHC language extensions such as OverloadedStrings , TypeApplications , and FlexibleContexts . A cursory understanding of QuasiQuotes is useful but not essential. You need a working haskell development environment with either stack or cabal . If you are using cabal, use GHC version 8.8.4. Quickstart \u00b6 Let us set up a project first. Create a project \u00b6 Stack stack new webgear-guide simple --resolver lts-16.12 cd webgear-guide Cabal cabal update mkdir webgear-guide cd webgear-guide cabal init --application-dir = src Adjust dependencies \u00b6 Edit webgear-guide.cabal and add the following dependencies under build-depends section: build-depends : base ==4.13.0.0 , webgear-server ==0.2.0 , mtl ==2.2.2 , wai ==3.2.2.1 , warp ==3.3.13 , text ==1.2.4.0 , bytestring ==0.10.10.1 , time ==1.9.3 , unordered-containers ==0.2.10.0 , hashable ==1.3.0.0 , aeson ==1.4.7.1 , http-types ==0.12.3 In addition to this, if you are using stack, add the following to stack.yaml : extra-deps : - webgear-server-0.2.0 Stack stack build Cabal cabal build Tip If this is the first time, it will take a long time to download and build the dependencies. Subsequent builds will use cached artifacts and will be faster.","title":"Introduction"},{"location":"guide/introduction/#webgear-user-guide","text":"","title":"WebGear User Guide"},{"location":"guide/introduction/#introduction","text":"WebGear is a library to build composable, extensible, type-safe APIs. This guide is designed to help you get started with WebGear. It follows a tutorial style; if you are looking for reference material, see the API documentation .","title":"Introduction"},{"location":"guide/introduction/#requirements","text":"You need a good understanding of Haskell programming language features such as type classes, monads, monad transformers to follow along this guide. WebGear uses a small set of GHC haskell features that are generally considered advanced. But this guide does not assume that you are an expert in these. All such features will be explained in this guide. However, it is assumed that you understand some basic GHC language extensions such as OverloadedStrings , TypeApplications , and FlexibleContexts . A cursory understanding of QuasiQuotes is useful but not essential. You need a working haskell development environment with either stack or cabal . If you are using cabal, use GHC version 8.8.4.","title":"Requirements"},{"location":"guide/introduction/#quickstart","text":"Let us set up a project first.","title":"Quickstart"},{"location":"guide/introduction/#create-a-project","text":"Stack stack new webgear-guide simple --resolver lts-16.12 cd webgear-guide Cabal cabal update mkdir webgear-guide cd webgear-guide cabal init --application-dir = src","title":"Create a project"},{"location":"guide/introduction/#adjust-dependencies","text":"Edit webgear-guide.cabal and add the following dependencies under build-depends section: build-depends : base ==4.13.0.0 , webgear-server ==0.2.0 , mtl ==2.2.2 , wai ==3.2.2.1 , warp ==3.3.13 , text ==1.2.4.0 , bytestring ==0.10.10.1 , time ==1.9.3 , unordered-containers ==0.2.10.0 , hashable ==1.3.0.0 , aeson ==1.4.7.1 , http-types ==0.12.3 In addition to this, if you are using stack, add the following to stack.yaml : extra-deps : - webgear-server-0.2.0 Stack stack build Cabal cabal build Tip If this is the first time, it will take a long time to download and build the dependencies. Subsequent builds will use cached artifacts and will be faster.","title":"Adjust dependencies"}]}